### **附錄**

---

#### **附錄A：常用公式與定理**

計算幾何學涉及許多基本的數學公式和定理，這些公式和定理在解決幾何問題時起著至關重要的作用。本節將總結一些常用的公式和定理，供讀者查閱。

---

##### **A.1 凸包相關公式**

- **凸包定義**  
  凸包是包含一組點的最小凸多邊形，其中每個點都位於該多邊形的內部或邊界上。對於一組給定的點集 \( P = \{ p_1, p_2, \dots, p_n \} \)，凸包是這些點的最小凸集合，記作 \( \text{Conv}(P) \)。

- **Graham掃描算法的時間複雜度**  
  在計算一組點的凸包時，Graham掃描算法的時間複雜度為 \( O(n \log n) \)，其中 \( n \) 是點集的大小。這是由於排序步驟的時間複雜度。

---

##### **A.2 最近點對問題**

- **最近點對定理**  
  給定一組平面上的點，最近點對定理表明，在該點集上存在一對點 \( p_i \) 和 \( p_j \) 使得它們之間的距離最短。這個問題的最優解法使用分治法，時間複雜度為 \( O(n \log n) \)。

- **兩點間距離公式**  
  在二維空間中，兩點 \( p(x_1, y_1) \) 和 \( q(x_2, y_2) \) 之間的歐氏距離為：
  \[
  d(p, q) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
  \]

---

##### **A.3 Delaunay三角剖分與Voronoi圖**

- **Delaunay三角剖分的性質**  
  Delaunay三角剖分是給定一組點的最優三角剖分，使得每個三角形的外接圓內部不包含其他點。它的主要性質包括：  
  - 若點集 \( P \) 的Delaunay三角剖分中的三角形的外接圓不包含其他點，那麼該剖分是Delaunay三角剖分。
  - 若三角形的外接圓包含點集中的其他點，則該三角形不屬於Delaunay三角剖分。

- **Voronoi圖的性質**  
  Voronoi圖是將平面劃分為若干區域，每個區域包含一個生成點，並且該區域內的所有點都比其他區域的生成點更接近。Voronoi圖的主要性質：  
  - 每個Voronoi區域的邊是兩個相鄰生成點的中垂線。
  - Voronoi圖可以用來解決最近鄰查詢問題。

---

#### **附錄B：計算幾何學的術語表**

本節提供了計算幾何學中常見的術語及其簡單定義，幫助讀者快速理解相關概念。

---

- **凸集**：在平面或空間中，一個點集如果對於集內的任意兩點，連接這兩點的直線段也完全位於該集內，則該集為凸集。

- **凸包**：給定一組點，凸包是包含這些點的最小凸多邊形。

- **Delaunay三角剖分**：一種三角形剖分方式，其中每個三角形的外接圓內部不包含其他點。

- **Voronoi圖**：將平面劃分為若干區域，每個區域對應一個生成點，該區域內的所有點都比其他區域的生成點更接近。

- **範圍查詢**：在空間數據結構中，範圍查詢是指查找位於某個特定範圍內的所有元素。

- **最近點對**：在一組點中，兩點之間的距離最小的那一對。

- **掃描線算法**：一種基於掃描線的計算幾何算法，用於處理各種幾何問題，如多邊形交集、最近點對等。

---

#### **附錄C：練習答案與程式碼範例**

在學習計算幾何學時，通過實際編程和解決問題可以加深理解。本節提供了一些練習題的答案以及程式碼範例，幫助讀者進行練習。

---

##### **C.1 練習題答案**

1. **凸包算法的實現**  
   給定一組點，使用 Graham掃描算法計算凸包的過程如下：  
   1. 將點按極角排序。
   2. 遍歷排序後的點，構造凸包。
   3. 返回最終的凸包。

2. **最近點對問題的解法**  
   使用分治法來解決最近點對問題：
   1. 按照 x 坐標排序點集。
   2. 遞迴地將問題分成兩部分，並求解每部分的最短距離。
   3. 合併結果，找到跨越中線的最短距離。

##### **C.2 程式碼範例**

- **Graham掃描算法（Python實現）**

```python
def graham_scan(points):
    # 排序點集
    points = sorted(points, key=lambda p: (p[0], p[1]))
    # 計算凸包
    def cross(o, a, b):
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

    hull = []
    for p in points:
        while len(hull) >= 2 and cross(hull[-2], hull[-1], p) <= 0:
            hull.pop()
        hull.append(p)
    
    return hull
```

- **最近點對問題（Python實現）**

```python
import math

def closest_pair(points):
    points = sorted(points)
    
    def distance(p1, p2):
        return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)

    def closest_pair_rec(points):
        if len(points) <= 3:
            return min([distance(points[i], points[j]) for i in range(len(points)) for j in range(i+1, len(points))])

        mid = len(points) // 2
        left = points[:mid]
        right = points[mid:]
        
        d_left = closest_pair_rec(left)
        d_right = closest_pair_rec(right)
        d = min(d_left, d_right)
        
        return d

    return closest_pair_rec(points)

# 範例
points = [(1, 2), (3, 4), (5, 6), (7, 8)]
print(closest_pair(points))
```

--- 

**附錄總結**

附錄部分提供了計算幾何學中的常用公式與定理、術語表，以及練習題答案與程式碼範例。這些內容對於讀者深入理解計算幾何問題的解法，並進行實際編程實踐具有重要參考價值。